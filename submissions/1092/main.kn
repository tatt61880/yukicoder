func main()
	var p: int :: cui@inputInt()
	var n: int :: cui@inputInt()
	var a: []int :: #[n]int
	for i(0, n - 1)
		do a[i] :: cui@inputInt()
	end for
	
	var ans: @modInt :: (#@modInt).init(a[0], p)
	var s: []char :: cui@input()
	for i(0, n - 2)
		var x: int :: a[i + 1]
		switch(s[i])
		case '+'
			do ans.add(x)
		case '-'
			do ans.sub(x)
		case '*'
			do ans.mul(x)
		case '/'
			do ans.div(x)
		end switch
	end for
	do cui@print("\{ans}\n")
end func

; val, mod, a, b: 0 to 2 ^ 31.
class modInt()
	var val: int
	var mod: int
	+func init(val: int, mod: int): modInt
		do me.val :: val % mod
		do me.mod :: mod
		ret me
	end func
	+func add(a: int): modInt
		do me.val :+ a
		if(me.val >= me.mod)
			do me.val :- me.mod
		end if
		ret me
	end func
	+func sub(a: int): modInt
		if(me.val < a)
			do me.val :+ me.mod
		end if
		do me.val :- a
		ret me
	end func
	+func mul(a: int): modInt
		do me.val :: me.val * a % me.mod
		ret me
	end func
	+func div(a: int): modInt
		do me.val :: me.val * me.modPow(a, me.mod - 2) % me.mod
		ret me
	end func
	+func pow(a: int): modInt
		do me.val :: me.modPow(me.val, a)
		ret me
	end func
	+*func toStr(): []char
		ret "\{me.val}"
	end func
	
	func modPow(a: int, b: int): int
		if(b = 0)
			ret 1
		end if
		var res: int :: me.modPow(a, b / 2)
		do res :: res * res % me.mod
		if(b % 2 = 1)
			do res :: res * a % me.mod
		end if
		ret res
	end func
end class
