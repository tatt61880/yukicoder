func main()
	const invalid: int :: lib@intMax
	var n: int :: cui@inputInt()
	var a: []int :: #[n]int
	for i(0, n - 1)
		do a[i] :: cui@inputInt()
	end for
	var lMin: []int :: #[n]int
	var rMin: []int :: #[n]int
	block
		var min: int :: a[0]
		for i(1, n - 1)
			do lMin[i] :: min
			do min :: [min, a[i]].min()
		end for
	end block
	block
		var min: int :: a[n - 1]
		for i(n - 2, 0, -1)
			do rMin[i] :: min
			do min :: [min, a[i]].min()
		end for
	end block
	var lLow: []int :: #[n]int
	var rLow: []int :: #[n]int
	block
		var set: Set :: #Set
		do set.add(a[0])
		for i(1, n - 1)
			var p: Node :: set.lower_bound(a[i])
			do lLow[i] :: p =& null ?(-1, p.key)
			do set.add(a[i])
		end for
	end block
	block
		var set: Set :: #Set
		do set.add(a[n - 1])
		for i(n - 2, 0, -1)
			var p: Node :: set.lower_bound(a[i])
			do rLow[i] :: p =& null ?(-1, p.key)
			do set.add(a[i])
		end for
	end block
	
	var ans: int :: invalid
	for i(1, n - 2)
		var v: int :: a[i]
		; ^
		var lm: int :: lMin[i]
		var rm: int :: rMin[i]
		if(lm < v & v > rm)
			do ans :: [ans, lm + v + rm].min()
		end if
		; v
		var ll: int :: lLow[i]
		var rl: int :: rLow[i]
		if(ll > v & v < rl)
			do ans :: [ans, ll + v + rl].min()
		end if
	end for
	if(ans = invalid)
		do ans :: -1
	end if
	do cui@print("\{ans}\n")
	
	class Node()
		+var height: int
		+var key: int
		+var lst: Node
		+var rst: Node
		+*func toStr(): []char
			ret "\{me.key}"
		end func
		+func init(height: int, key: int): Node
			do me.height :: height
			do me.key :: key
			do me.lst :: null
			do me.rst :: null
			ret me
		end func
	end class
	func height(t: Node): int
		ret t =& null ?(0, t.height)
	end func
	func bias(t: Node): int
		ret height(t.lst) - height(t.rst)
	end func
	func modHeight(t: Node)
		do t.height :: 1 + lib@max(height(t.lst), height(t.rst))
	end func
	func rotateL(v: Node): Node
		var u: Node :: v.rst
		var t: Node :: u.lst
		do u.lst :: v
		do v.rst :: t
		ret u
	end func
	func rotateR(u: Node): Node
		var v: Node :: u.lst
		var t: Node :: v.rst
		do v.rst :: u
		do u.lst :: t
		ret v
	end func
	func rotateLR(t: Node): Node
		do t.lst :: rotateL(t.lst)
		ret rotateR(t)
	end func
	func rotateRL(t: Node): Node
		do t.rst :: rotateR(t.rst)
		ret rotateL(t)
	end func
	
	; AVL Tree
	class Set()
		var root: Node
		var change: bool
		var lmax: int
		+func balanceL(t: Node): Node
			if(!me.change)
				ret t
			end if
			var h: int :: height(t)
			if(bias(t) = 2)
				if(bias(t.lst) >= 0)
					do t :: rotateR(t)
				else
					do t :: rotateLR(t)
				end if
			else
				do modHeight(t)
			end if
			do me.change :: (h <> height(t))
			ret t
		end func
		+func balanceR(t: Node): Node
			if(!me.change)
				ret t
			end if
			var h: int :: height(t)
			if(bias(t) = -2)
				if(bias(t.rst) <= 0)
					do t :: rotateL(t)
				else
					do t :: rotateRL(t)
				end if
			else
				do modHeight(t)
			end if
			do me.change :: (h <> height(t))
			ret t
		end func
		+func add(key: int)
			do me.root :: me.addSub(me.root, key)
		end func
		+func addSub(t: Node, key: int): Node
			if(t =& null)
				do me.change :: true
				ret(#Node).init(1, key)
			elif(key < t.key)
				do t.lst :: me.addSub(t.lst, key)
				ret me.balanceL(t)
			elif(key > t.key)
				do t.rst :: me.addSub(t.rst, key)
				ret me.balanceR(t)
			else
				do me.change :: false
				ret t
			end if
		end func
		+func find(key: int): Node
			var t: Node :: me.root
			while loop(t <>& null)
				if(key < t.key)
					do t :: t.lst
				elif(key > t.key)
					do t :: t.rst
				else
					break loop
				end if
			end while
			ret t
		end func
		+func lower_bound(key: int): Node
			var t: Node :: me.root
			if(t =& null)
				ret null
			end if
			while(true)
				if(key < t.key)
					if(t.lst =& null)
						ret t
					end if
					if(key > t.lst.key)
						ret t
					end if
					do t :: t.lst
				elif(key > t.key)
					if(t.rst =& null)
						ret null
					end if
					do t :: t.rst
				else
					ret t
				end if
			end while
		end func
	end class
end func
