func main()
	const invalid: int :: lib@intMax
	var n: int :: cui@inputInt()
	var a: []int :: #[n]int
	for i(0, n - 1)
		do a[i] :: cui@inputInt()
	end for
	var lMin: []int :: #[n]int
	var rMin: []int :: #[n]int
	block
		var min: int :: a[0]
		for i(1, n - 1)
			do lMin[i] :: min
			do min :: [min, a[i]].min()
		end for
	end block
	block
		var min: int :: a[n - 1]
		for i(n - 2, 0, -1)
			do rMin[i] :: min
			do min :: [min, a[i]].min()
		end for
	end block
	var lLow: []int :: #[n]int
	var rLow: []int :: #[n]int
	block
		var set: Set :: #Set
		do set.add(a[0])
		for i(1, n - 1)
			var p: Node :: set.lower_bound(a[i])
			do lLow[i] :: p =& null ?(-1, p.key)
			do set.add(a[i])
		end for
	end block
	block
		var set: Set :: #Set
		do set.add(a[n - 1])
		for i(n - 2, 0, -1)
			var p: Node :: set.lower_bound(a[i])
			do rLow[i] :: p =& null ?(-1, p.key)
			do set.add(a[i])
		end for
	end block
	
	var ans: int :: invalid
	for i(1, n - 2)
		var v: int :: a[i]
		; ^
		var lm: int :: lMin[i]
		var rm: int :: rMin[i]
		if(lm < v & v > rm)
			do ans :: [ans, lm + v + rm].min()
		end if
		; v
		var ll: int :: lLow[i]
		var rl: int :: rLow[i]
		if(ll > v & v < rl)
			do ans :: [ans, ll + v + rl].min()
		end if
	end for
	if(ans = invalid)
		do ans :: -1
	end if
	do cui@print("\{ans}\n")
	
	class Node()
		+var height: int
		+var key: int
		+var prev: Node
		+var next: Node
		+var lst: Node
		+var rst: Node
		+func init(key: int, prev: Node, next: Node): Node
			do me.height :: 1
			do me.key :: key
			do me.prev :: prev
			do me.next :: next
			ret me
		end func
	end class
	
	; AVL Tree
	class Set()
		var root: Node
		var change: bool
		var num: int
		+func size(): int
			ret me.num
		end func
		+func begin(): Node
			var t: Node :: me.root
			while(true)
				if(t.lst =& null)
					ret t
				end if
				do t :: t.lst
			end while
		end func
		func height(t: Node): int
			ret t =& null ?(0, t.height)
		end func
		func bias(t: Node): int
			ret me.height(t.lst) - me.height(t.rst)
		end func
		func modHeight(t: Node)
			do t.height :: 1 + lib@max(me.height(t.lst), me.height(t.rst))
		end func
		func rotateL(v: Node): Node
			var u: Node :: v.rst
			var t: Node :: u.lst
			do u.lst :: v
			do v.rst :: t
			ret u
		end func
		func rotateR(u: Node): Node
			var v: Node :: u.lst
			var t: Node :: v.rst
			do v.rst :: u
			do u.lst :: t
			ret v
		end func
		func rotateLR(t: Node): Node
			do t.lst :: me.rotateL(t.lst)
			ret me.rotateR(t)
		end func
		func rotateRL(t: Node): Node
			do t.rst :: me.rotateR(t.rst)
			ret me.rotateL(t)
		end func
		+func balanceL(t: Node): Node
			if(!me.change)
				ret t
			end if
			var h: int :: me.height(t)
			if(me.bias(t) = 2)
				if(me.bias(t.lst) >= 0)
					do t :: me.rotateR(t)
				else
					do t :: me.rotateLR(t)
				end if
			else
				do me.modHeight(t)
			end if
			do me.change :: (h <> me.height(t))
			ret t
		end func
		+func balanceR(t: Node): Node
			if(!me.change)
				ret t
			end if
			var h: int :: me.height(t)
			if(me.bias(t) = -2)
				if(me.bias(t.rst) <= 0)
					do t :: me.rotateL(t)
				else
					do t :: me.rotateRL(t)
				end if
			else
				do me.modHeight(t)
			end if
			do me.change :: (h <> me.height(t))
			ret t
		end func
		+func add(key: int)
			do me.root :: me.addSub(me.root, null, key)
		end func
		+func addSub(t: Node, parent: Node, key: int): Node
			if(t =& null)
				var a: Node
				do me.change :: true
				if(parent =& null)
					do a :: (#Node).init(key, null, null)
				elif(key < parent.key)
					do a :: (#Node).init(key, parent.prev, parent)
					if(parent.prev <>& null)
						do parent.prev.next :: a
					end if
					do parent.prev :: a
				elif(key > parent.key)
					do a :: (#Node).init(key, parent, parent.next)
					if(parent.next <>& null)
						do parent.next.prev :: a
					end if
					do parent.next :: a
				end if
				do me.num :+ 1
				ret a
			elif(key < t.key)
				do t.lst :: me.addSub(t.lst, t, key)
				ret me.balanceL(t)
			elif(key > t.key)
				do t.rst :: me.addSub(t.rst, t, key)
				ret me.balanceR(t)
			else
				do me.change :: false
				ret t
			end if
		end func
		+func find(key: int): Node
			var t: Node :: me.root
			while loop(t <>& null)
				if(key < t.key)
					do t :: t.lst
				elif(key > t.key)
					do t :: t.rst
				else
					break loop
				end if
			end while
			ret t
		end func
		+func exist(key: int): bool
			ret me.find(key) <>& null
		end func
		+func lower_bound(key: int): Node
			var t: Node :: me.root
			if(t =& null)
				ret null
			end if
			while(true)
				if(key < t.key)
					if(t.lst =& null)
						ret t
					end if
					if(key > t.lst.key & t.lst.rst =& null)
						ret t
					end if
					do t :: t.lst
				elif(key > t.key)
					if(t.rst =& null)
						ret null
					end if
					do t :: t.rst
				else
					ret t
				end if
			end while
		end func
	end class
end func
