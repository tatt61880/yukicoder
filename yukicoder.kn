; userIdのみ要変更です。
const userId: int :: 5112
const yukicoderBase: []char :: "https://yukicoder.me/"
const dirHtml: []char :: "./html/"
const dirSubmissions: []char :: "./submissions/"
var dictSubmitTitle: dict<int, []char>
var dictSubmitLang: dict<int, []char>
var dictLangExtension: dict<[]char, []char>
var regexUrl: regex@Regex
var regexUrl2: regex@Regex

func main()
	if(!@makeDir(@dirHtml))
		ret
	end if
	
	{
    <td><a href="/submissions/322195">322195</a></td>
    <td class="time">2019-03-12 00:09:26</td>
    <td><a href="?submitter=5112" title="このユーザーの提出の表示"><i class="fa fa-search"></i></a></td>
    <td class="table_username">
        <a href="/users/5112"><img  alt="tatt61880"  class="icon" src="https://avatars0.githubusercontent.com/u/2398152?v=4">tatt61880</a></td>
    <td><a href="/problems/no/129">No.129 お年玉(2)</a></td>
    <td>Kuin(beta)</td>
	}
	do @regexUrl :: regex@makeRegex("\"/submissions/(\\d+)\"[\\d\\D]*?/problems/no/(\\d+)\">([^<]*)[\\d\\D]*?<td>(.*?)</td>")
	assert @regexUrl <>& null
	do @regexUrl2 :: regex@makeRegex("/submissions/(\\d+)/")
	assert @regexUrl2 <>& null
	
	var id: int :: 0
	var dictProblemSubmit: dict<int, int> :: #dict<int, int>
	do @dictSubmitTitle :: #dict<int, []char>
	do @dictSubmitLang :: #dict<int, []char>
	while loop(true)
		do id :+ 1
		var url: []char :: "\{@yukicoderBase}users/\{@userId}/submissions?page=\{id}&status=AC&date_asc=enabled"
		var filepath: []char :: "\{@dirHtml}\{id}.html"
		if(file@exist(filepath))
			var filepathNext: []char :: "\{@dirHtml}\{id + 1}.html"
			if(file@exist(filepathNext))
				; データが更新されていないと思われるページは取得しません。
				skip loop
			end if
		end if
		var data: []char :: @fetchData(url)
		if(data =& null)
			break loop
		end if
		var result: [][][]char :: @regexUrl.findAll(&, data)
		if(result =& null)
			break loop
		end if
		for i(0, ^result - 1)
			var subumitId: int :: result[i][1].toInt(&)
			var problemId: int :: result[i][2].toInt(&)
			var title: []char :: result[i][3]
			var language: []char :: result[i][4]
			
			do title :: @unsanitized(title)
			do language :: @unsanitized(language)
			
			do dictProblemSubmit.add(problemId, subumitId)
			do @dictSubmitTitle.add(subumitId, title)
			do @dictSubmitLang.add(subumitId, language)
		end for
		var writer: file@Writer :: file@makeWriter(filepath, false)
		do writer.writeStr(data)
		do writer.fin()
	end while
	
	if(!@makeDir(@dirSubmissions))
		ret
	end if
	
	if(!@initExtensions())
		do lib@exitCode(1)
		do cui@print("拡張子データの初期化に失敗しました。\n")
		ret
	end if
	
	do dictProblemSubmit.forEach(callback, null)
	
	func callback(problemId: int, subumitId: int, _: kuin@Class): bool
		var title: []char :: @dictSubmitTitle.get(subumitId, &)
		var language: []char :: @dictSubmitLang.get(subumitId, &)
		var extension: []char :: @dictLangExtension.get(language, &)
		if(extension =& null)
			do @addExtension(language, &extension)
		end if
		var filepath: []char :: "\{@dirSubmissions}\{problemId}/main.\{extension}"
		var filepathUrl: []char :: "\{@dirSubmissions}\{problemId}/submission.url"
		var filepathTitle: []char :: "\{@dirSubmissions}\{problemId}/title.txt"
		var url: []char :: "\{@yukicoderBase}submissions/\{subumitId}/"
		if(file@exist(filepathUrl))
			var readerUrl: file@Reader :: file@makeReader(filepathUrl)
			do readerUrl.readLine()
			var ss: [][]char :: readerUrl.readLine().split("=")
			if(^ss = 2)
				var currentUrl: []char :: ss[1]
				do readerUrl.fin()
				var result: [][][]char :: @regexUrl2.findAll(&, currentUrl)
				if(result <>& null)
					var currentSubumitId: int :: result[0][1].toInt(&)
					do cui@print("\{subumitId} \{currentSubumitId}\n")
					if(subumitId <= currentSubumitId)
						ret true
					end if
				end if
			end if
		end if
		var urlSource: []char :: "\{@yukicoderBase}submissions/\{subumitId}/source"
		do cui@print("No.\{problemId}: ")
		var data: []char :: @fetchData(urlSource)
		if(data =& null)
			do cui@print("Error: Failed to find source code. [\{urlSource}]\n")
		else
			var dirPath: []char :: "\{@dirSubmissions}\{problemId}/"
			for i(0, 10)
				if(file@exist(dirPath))
					if(!file@delDir(dirPath))
						if(i = 10)
							do cui@print("Error: Failed to remove dir. [\{dirPath}]\n")
							ret false
						end if
						do lib@sleep(200)
					else
						do lib@sleep(500)
					end if
				else
					break i
				end if
			end for
			if(!@makeDir(dirPath))
				ret false
			end if
			var writer: file@Writer :: file@makeWriter(filepath, false)
			do writer.writeStr(data)
			do writer.fin()
			
			var writerUrl: file@Writer :: file@makeWriter(filepathUrl, false)
			do writerUrl.writeStr("[InternetShortcut]\n")
			do writerUrl.writeStr("URL="~ url)
			do writerUrl.fin()
			
			var writerTitle: file@Writer :: file@makeWriter(filepathTitle, false)
			do writerTitle.writeStr(title)
			do writerTitle.fin()
			ret true
		end if
		ret false
	end func
end func

func fetchData(url: []char): []char
	if(url =& null)
		do cui@print("urlがnullです。\n")
		ret null
	end if
	var http: net@Http :: net@makeHttp(url, false, "Kuin")
	do cui@print("Fetching data: \{url}\n")
	do lib@sleep(1000)
	
	if(http =& null)
		do cui@print("接続に失敗しました。[\{url}]\n")
		ret null
	else
		var data: []char
		for i(1, 300)
			do lib@sleep(10)
			do data :: http.get()
			if(data <>& null)
				ret data
			end if
		end for
		do http.fin()
	end if
	do cui@print("データの取得に失敗しました。[\{url}]\n")
	ret null
end func

func makeDir(dirPath: []char): bool
	if(file@exist(dirPath))
		ret true
	else
		if(file@makeDir(dirPath))
			ret true
		else
			do lib@exitCode(1)
			do cui@print("\{dirPath}を作成できません。\n")
			ret false
		end if
	end if
end func

var arrLanguages: [][]char
var arrExtensions: [][]char

func initExtensions(): bool
	var extensionFilepath: []char :: "\{file@exeDir()}extensions.csv"
	var reader: file@Reader :: file@makeReader(extensionFilepath)
	if(reader =& null)
		do lib@exitCode(1)
		do cui@print("\{extensionFilepath} can't be opened.\n")
		ret false
	end if
	do reader.delimiter(",\n")
	do @arrLanguages :: #[0][]char
	do @arrExtensions :: #[0][]char
	while(!reader.term())
		var language: []char :: reader.readStr()
		var extension: []char :: reader.readStr()
		do @arrLanguages :~ [language]
		do @arrExtensions :~ [extension]
	end while
	do @dictLangExtension :: #dict<[]char, []char>
	ret true
end func

func addExtension(language: []char, extension: &[]char)
	do extension :: "unknown"
	for i(^@arrLanguages - 1, 0, -1)
		if(language.findStr(@arrLanguages[i], -1) <> -1)
			do extension :: @arrExtensions[i]
			break i
		end if
	end for
	do @dictLangExtension.add(language, extension)
end func

func unsanitized(str: []char): []char
	var res: []char :: ""
	var i: int :: 0
	while(i < ^str)
		if(i < ^str - 1 & str[i] = '&')
			if(str[i + 1] = '#')
				do i :+ 2
				var v: int :: 0
				while(i < ^str & str[i] <> ';')
					do v :* 10
					do v :+ str[i] $ int - '0' $ int
					do i :+ 1
				end while
				do res :~ [v $ char]
			else
				do res :~ ['&']
			end if
		else
			do res :~ [str[i]]
		end if
		do i :+ 1
	end while
	ret res
end func
